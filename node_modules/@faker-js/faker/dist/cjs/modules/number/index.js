"use strict";var o=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var x=Object.prototype.hasOwnProperty;var d=(u,e)=>{for(var n in e)o(u,n,{get:e[n],enumerable:!0})},w=(u,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of h(e))!x.call(u,t)&&t!==n&&o(u,t,{get:()=>e[t],enumerable:!(r=s(e,t))||r.enumerable});return u};var M=u=>w(o({},"__esModule",{value:!0}),u);var I={};d(I,{NumberModule:()=>y});module.exports=M(I);var a=require("../../errors/faker-error"),g=require("../../internal/deprecated"),c=require("../../internal/module-base");class y extends c.SimpleModuleBase{int(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=Number.MAX_SAFE_INTEGER}=e,t=Math.ceil(n),i=Math.floor(r);if(t===i)return t;if(i<t)throw r>=n?new a.FakerError(`No integer value between ${n} and ${r} found.`):new a.FakerError(`Max ${r} should be greater than min ${n}.`);const m=this.faker._randomizer.next();return Math.floor(m*(i+1-t)+t)}float(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=1,fractionDigits:t,precision:i,multipleOf:f=i,multipleOf:m=i!=null?i:t==null?void 0:10**-t}=e;if(i!=null&&(0,g.deprecated)({deprecated:"faker.number.float({ precision })",proposed:"faker.number.float({ multipleOf })",since:"8.4",until:"9.0"}),r===n)return n;if(r<n)throw new a.FakerError(`Max ${r} should be greater than min ${n}.`);if(t!=null){if(f!=null)throw new a.FakerError("multipleOf and fractionDigits cannot be set at the same time.");if(!Number.isInteger(t))throw new a.FakerError("fractionDigits should be an integer.");if(t<0)throw new a.FakerError("fractionDigits should be greater than or equal to 0.")}if(m!=null){if(m<=0)throw new a.FakerError("multipleOf/precision should be greater than 0.");const b=Math.log10(m),l=m<1&&Number.isInteger(b)?10**-b:1/m;return this.int({min:n*l,max:r*l})/l}return this.faker._randomizer.next()*(r-n)+n}binary(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=1}=e;return this.int({max:r,min:n}).toString(2)}octal(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=7}=e;return this.int({max:r,min:n}).toString(8)}hex(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=15}=e;return this.int({max:r,min:n}).toString(16)}bigInt(e={}){var f,m;(typeof e=="bigint"||typeof e=="number"||typeof e=="string"||typeof e=="boolean")&&(e={max:e});const n=BigInt((f=e.min)!=null?f:0),r=BigInt((m=e.max)!=null?m:n+BigInt(999999999999999));if(r===n)return n;if(r<n)throw new a.FakerError(`Max ${r} should be larger then min ${n}.`);const t=r-n,i=BigInt(this.faker.string.numeric({length:t.toString(10).length,allowLeadingZeros:!0}))%(t+BigInt(1));return n+i}}0&&(module.exports={NumberModule});
